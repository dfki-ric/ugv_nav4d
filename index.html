<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ugv_nav4d: ugv_nav4d</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ugv_nav4d
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title"><a class="el" href="namespaceugv__nav4d.html">ugv_nav4d</a> </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> CI build (main): <img src="https://github.com/dfki-ric/ugv_nav4d/actions/workflows/c-cpp.yml/badge.svg" alt="Main" style="pointer-events: none;" class="inline"/></p>
<p>JOSS Paper: <a href="https://doi.org/10.21105/joss.06983"><img src="https://joss.theoj.org/papers/10.21105/joss.06983/status.svg" alt="DOI" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md0"></a>
ugv_nav4d: Advanced Multi-Surface Navigation for Unmanned Ground Vehicles Using 4D Path Planning Techniques</h1>
<p>A 4D (X,Y,Z, Theta) Planner for Unmanned Ground Vehicles.</p>
<p>&lt;figure&gt; <img src="doc/figures/ugv_nav4d_logo.jpeg" alt="" height="200" width="200" class="inline"/> &lt;/figure&gt;</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Statement of need</h2>
<p>Accurate ground surface representation is crucial for ground-based robots in complex terrains. The <a href="https://docs.nav2.org/">ROS2 Navigation Stack</a>, which uses voxel maps for 3D navigation, often loses detail and accuracy, especially in multi-storey environments, due to its discrete voxelization and separate costmaps for each floor.</p>
<p>We propose <a class="el" href="namespaceugv__nav4d.html">ugv_nav4d</a>, a path planner that enhances environmental representation with <a href="https://github.com/envire/slam-maps">Multi-Layered Surface Maps</a> (MLS) and a 3D <a href="https://github.com/dfki-ric/traversability_generator3d.git">Traversability Map</a>. Ugv_nav4d avoids the "stepping" effect of voxel maps by using a continuous grid and detailed vertical information, providing smoother and more accurate terrain modeling.</p>
<p>Unlike nav2, <a class="el" href="namespaceugv__nav4d.html">ugv_nav4d</a> simplifies planning with a single TraversabilityMap3D, which contains detailed ground surface data, offering a superior alternative to nav2â€™s 3D costmaps. For users, MLS maps provide a smoother, more realistic view of terrain compared to the blocky voxel maps, enhancing navigation and decision-making in complex environments.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Installation</h2>
<p>Follow the steps to peform a standalone build of the library.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
System Requirements</h3>
<div class="fragment"><div class="line">OS: Ubuntu 20.04, Ubuntu 22.04, Ubuntu 24.04</div>
</div><!-- fragment --><p> See <a href="source_dependencies/install_os_dependencies.bash">install_os_dependencies.bash</a> for further os dependencies.</p>
<h4><a class="anchor" id="autotoc_md4"></a>
Get the library</h4>
<div class="fragment"><div class="line">git clone https://github.com/dfki-ric/ugv_nav4d.git</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md5"></a>
Automatic Install of Dependencies &amp; Build</h4>
<p>Install dependencies automatically when building <a class="el" href="namespaceugv__nav4d.html">ugv_nav4d</a>. Defining <code>-DINSTALL_DEPS=ON</code> for cmake, builds and installs the source dependencies automatically. When <code>-DCMAKE_INSTALL_PREFIX</code> is used, the dependencies are also installed there. The install script generates an env.sh file in the <code>CMAKE_INSTALL_PREFIX</code> folder. It exports all neccessary environment variables.</p>
<div class="fragment"><div class="line">cd ugv_nav4d</div>
<div class="line">mkdir build &amp;&amp; cd build</div>
<div class="line">cmake -DINSTALL_DEPS=ON -DCMAKE_INSTALL_PREFIX=./install ..</div>
<div class="line">make install</div>
<div class="line">source install/env.sh</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md6"></a>
Manual Installation of Dependencies &amp; Build</h4>
<p>Skip this step if you already installed the dependencies automatically from the previous step.</p>
<p>Follow the steps to manually install dependencies. Define a path_to_install_folder e.g. <code>./install</code> where the dependencies will be installed</p>
<div class="fragment"><div class="line">cd ugv_nav4d</div>
<div class="line">mkdir build &amp;&amp; cd source_dependencies</div>
<div class="line">bash ./install_os_dependencies.bash</div>
<div class="line">bash ./build.bash ../build/install</div>
</div><!-- fragment --><p>After all dependencies have been installed. Go back to the main folder to build and install <a class="el" href="namespaceugv__nav4d.html">ugv_nav4d</a> like any other cmake project.</p>
<div class="fragment"><div class="line">cd ../build</div>
<div class="line">source install/env.sh</div>
<div class="line">cmake -DCMAKE_INSTALL_PREFIX=./install -DTESTS_ENABLED=OFF -DENABLE_DEBUG_DRAWINGS=OFF -DCMAKE_BUILD_TYPE=RELEASE ..</div>
<div class="line">make install</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md7"></a>
Compiling inside a ROCK environment [Only for ROCK users]</h4>
<p>See the <code>manifest.xml</code> for an up to date list of dependencies. If you are ROCK user then include the package_set which contains the <code>dfki-ric/orogen-ugv_nav4d</code> package in your autoproj manifest file.</p>
<h4><a class="anchor" id="autotoc_md8"></a>
API Documentation</h4>
<p>The API documentation can be found at <a href="https://dfki-ric.github.io/ugv_nav4d/">https://dfki-ric.github.io/ugv_nav4d/</a></p>
<h4><a class="anchor" id="autotoc_md9"></a>
GUI Usage &amp; Tests</h4>
<p>Source the <code>env.sh</code> in the install folder.</p>
<p>At first, get the test point cloud map and start the GUI. </p><div class="fragment"><div class="line">cd ..</div>
<div class="line">source build/install/env.sh</div>
<div class="line">wget https://zenodo.org/record/13789320/files/parking_deck.ply</div>
<div class="line">ugv_nav4d_bin-qt5 parking_deck.ply 0.3</div>
</div><!-- fragment --><p> <img src="doc/figures/planner_gui.png" alt="PlannerGui" class="inline"/></p>
<p>A basic GUI is loaded with the Multi-layer Surface Map of a parking deck environment. Use the mouse left-click to select a start position and the mouse right-click to select the goal position. The sliders can be used to changed the orientations of start and goal positions. Click on the button <code>Plan</code> to plan a path.</p>
<p><img src="doc/figures/planner_gui_result.png" alt="PlannerGuiResult" class="inline"/></p>
<p>The button <code>Create PlannerDump</code> can be used to save the planner's state. The created file e.g. ugv4d_dump_xxxx.bin can be replayed using the executable <code>ugv_naved_replay</code>.</p>
<div class="fragment"><div class="line">ugv_nav4d_replay ugv4d_dump_xxxx.bin</div>
</div><!-- fragment --><p>An additional GUI is provided for tuning of parameters used in the generation of motion primitives. The generated spline motion primitives are also visualized. Furthermore, the <code>vizkit3d::SbplSplineVisualization</code> plugin under <code>Properties</code> offers further options for visualizing and analyzing the splines for various start and end angles. <img src="doc/figures/motion_primitives_gui.png" alt="MotionPrimitivesGui" class="inline"/></p>
<p>Run the following executable in your terminal: </p><div class="fragment"><div class="line">sbpl_spline_viz_bin</div>
<div class="line">``````</div>
<div class="line"> </div>
<div class="line">#### Unit Tests</div>
<div class="line"> </div>
<div class="line">Build the library again but this time enable the `-DTESTS_ENABLED=ON`</div>
</div><!-- fragment --><p> cd build cmake -DCMAKE_INSTALL_PREFIX=./install -DTESTS_ENABLED=ON -DENABLE_DEBUG_DRAWINGS=OFF -DCMAKE_BUILD_TYPE=RELEASE .. make install </p><div class="fragment"><div class="line">The test executables are in the folder: `build/src/test/`.</div>
<div class="line"> </div>
<div class="line">---</div>
<div class="line"># ROS 2 Humble Test Environment with Turtlebot3 and Husky</div>
<div class="line"> </div>
<div class="line">This provides instructions for setting up a test environment using **Gazebo Fortress** for Husky and **Gazebo Classic** for Turtlebot3 with **ROS 2 Humble**. The setup includes configurations for using the Husky robot and ensures that the necessary resources are in place for smooth operation.</div>
<div class="line"> </div>
<div class="line">## Prerequisites</div>
<div class="line"> </div>
<div class="line">### 1. Install ROS2 Humble</div>
<div class="line">Ensure you have **ROS2 Humble** installed on your system. Follow the official page at [ROS2 Humble Debian Installation](https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debs.html)</div>
<div class="line"> </div>
<div class="line">### 2. Install Gazebo Fortress</div>
<div class="line">If you need to install **Gazebo Fortress**, follow the instructions provided on the official page at [Gazebo Installation](https://gazebosim.org/docs/latest/ros_installation/).</div>
<div class="line"> </div>
<div class="line">### 3. Install SLAM</div>
<div class="line">If you have a SLAM package which provides a pointcloud map on a topic then you can skip this step. If not then you can use [lidarslam_ros2](https://github.com/rsasaki0109/lidarslam_ros2). Please follow the build and install instructions from the original repository. Set the parameter `robot_frame_id: &quot;husky/base_link&quot;` for the `scanmatcher` node in [lidarslam.yaml](https://github.com/rsasaki0109/lidarslam_ros2/blob/a63b8fa2485e05251505b2bb209598285106bff2/lidarslam/param/lidarslam.yaml#L4)</div>
<div class="line"> </div>
<div class="line">Install libg2o:</div>
</div><!-- fragment --><p> sudo apt-get install -y ros-humble-libg2o </p><div class="fragment"><div class="line">### 4. Get ugv_nav4d_ros2 and a test environment for robot husky in gazebo</div>
</div><!-- fragment --><p> mkdir -p ~/your_ros2_workspace/src cd ~/your_ros2_workspace/src git clone <a href="https://github.com/dfki-ric/ugv_nav4d_ros2.git">https://github.com/dfki-ric/ugv_nav4d_ros2.git</a> </p><div class="fragment"><div class="line">You can clone the repo `ros2_humble_gazebo_sim` anywhere in your system. Here we clone it in the `your_ros2_workspace` folder.</div>
</div><!-- fragment --><p> cd ~/your_ros2_workspace git clone <a href="https://github.com/dfki-ric/ros2_humble_gazebo_sim.git">https://github.com/dfki-ric/ros2_humble_gazebo_sim.git</a> cd ros2_humble_gazebo_sim bash install_dependencies.bash </p><div class="fragment"><div class="line">### 5. Building the ROS 2 Workspace</div>
<div class="line">Before launching the simulation, source your env.sh from ugv_nav4d and build your ROS 2 workspace:</div>
</div><!-- fragment --><p> cd ~/your_ros2_workspace source path/to/ugv_nav4d/build/install/env.sh colcon build &ndash;cmake-args -DCMAKE_BUILD_TYPE=Release </p><div class="fragment"><div class="line"># Turlebot3 and Nav2 Integration</div>
<div class="line">Install [Nav2](https://docs.nav2.org/development_guides/build_docs/index.html) from the instructions on the homepage.</div>
<div class="line"> </div>
<div class="line">Follow the steps in this section to play around with a Turtlebot3 and Nav2. Ugv_nav4d expects a pointcloud map. The map can be provided by SLAM or static pointclouds as `PLY`. An example flat plane `PLY` file is used in these steps.</div>
<div class="line"> </div>
<div class="line">Install turtlebot3-gazebo package and launch simulation</div>
</div><!-- fragment --><p> sudo apt-get install ros-humble-turtlebot3-gazebo export GAZEBO_MODEL_PATH=$GAZEBO_MODEL_PATH:/opt/ros/humble/share/turtlebot3_gazebo/models export TURTLEBOT3_MODEL=waffle ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py headless:=false x_pose:=2.0 y_pose:=2.0 </p><div class="fragment"><div class="line">Clone a repo with config files for nav2 and ugv_nav4d</div>
</div><!-- fragment --><p> cd ~/your_ros2_workspace git clone <a href="#" onclick="location.href='mai'+'lto:'+'git'+'@g'+'ith'+'ub'+'.co'+'m'; return false;">git@g<span class="obfuscator">.nosp@m.</span>ithu<span class="obfuscator">.nosp@m.</span>b.com</a>:haider8645/turtlebot3_nav2_ugv_nav4d_config.git </p><div class="fragment"><div class="line">Start the nav2 controller_server.</div>
<div class="line"> </div>
<div class="line">Note: Please provide the fullpath for `your_ros2_workspace` in the launch file arguments.</div>
</div><!-- fragment --><p> cd turtlebot3_nav2_ugv_nav4d_config ros2 launch turtle_nav2.launch.py nav2_param_path:=/path/to/your_ros2_workspace/turtlebot3_nav2_ugv_nav4d_config/turtle_nav2.yaml rviz_config_path:=/path/to/your_ros2_workspace/turtlebot3_nav2_ugv_nav4d_config/turtle.rviz </p><div class="fragment"><div class="line">In a new terminal, configure and activate the nav2 controller_server</div>
</div><!-- fragment --><p> ros2 lifecycle set /controller_server configure ros2 lifecycle set /controller_server activate </p><div class="fragment"><div class="line">In a new terminal, start ugv_nav4d</div>
<div class="line"> </div>
<div class="line">Note: Please provide the fullpath for `your_ros2_workspace` in the launch file arguments and accordingly edit the parameter `mls_file_path` in `turtle_ugv_nav4d.yaml`.</div>
</div><!-- fragment --><p> ros2 launch ugv_nav4d_ros2 ugv_nav4d.launch.py goal_topic:=/goal_pose main_param_file:=/path/to/your_ros2_workspace/turtlebot3_nav2_ugv_nav4d_config/turtle_ugv_nav4d.yaml </p><div class="fragment"><div class="line">In new terminals, start scripts to send FollowPath action calls to nav2 and for Path visualization</div>
</div><!-- fragment --><p> cd ~/your_ros2_workspace/src/ugv_nav4d_ros2/scripts python3 follow_path_client.py </p><div class="fragment"><div class="line">and </div>
</div><!-- fragment --><p> cd ~/your_ros2_workspace/src/ugv_nav4d_ros2/scripts python3 visualize_path.py </p><div class="fragment"><div class="line">Visualize the MLS Map using</div>
</div><!-- fragment --><p> ros2 service call /ugv_nav4d_ros2/map_publish std_srvs/srv/Trigger </p><div class="fragment"><div class="line">You can now send goals to the planner using `2D Goal Pose` in rviz and visualize the results.</div>
<div class="line"> </div>
<div class="line"># Husky Integration</div>
<div class="line"> </div>
<div class="line">To ensure that Gazebo can find the robot model, you need to export the following environment variable. Replace /path/to/ with the actual **complete** path where you clone the repository `ros2_humble_gazebo_sim`. Add this command to your terminal:</div>
</div><!-- fragment --><p> export IGN_GAZEBO_RESOURCE_PATH=/path/to/your_ros2_workspace/ros2_humble_gazebo_sim/resource:$IGN_GAZEBO_RESOURCE_PATH </p><div class="fragment"><div class="line">Launch the Gazebo simulation by executing the following command in your terminal:</div>
</div><!-- fragment --><p> source ~/your_ros2_workspace/install/setup.bash cd ~/your_ros2_workspace/ros2_humble_gazebo_sim/simulation ros2 launch start.launch.py </p><div class="fragment"><div class="line">You can use the `Teleop` plugin of Gazebo for sending velocity commands to the robot. Click on the three dots in top-right corner of Gazebo window and search for `Teleop`. Select the plugin and adjust the values as shown in figure.</div>
<div class="line"> </div>
<div class="line">![GazeboTeleop](doc/figures/gazebo_teleop.png)</div>
<div class="line"> </div>
<div class="line">Alternative to the `Teleop` plugin, you can use a joystick for moving the robot. For this, set the argument `use_joystick:=True`. Adjust the config files in the folder `/config` of the `ros2_humble_gazebo_sim` package from Step 3. Provide the full paths to the arguments `joy_config_file` and `teleop_twist_config_file` as shown below:</div>
</div><!-- fragment --><p> ros2 launch start.launch.py use_joystick:=True joy_config_file:=/your_ros2_workspace/ros2_humble_gazebo_sim/simulation/config/joy_config.yaml teleop_twist_config_file:=/your_ros2_workspace/ros2_humble_gazebo_sim/simulation/config/teleop_twist_config.yaml </p><div class="fragment"><div class="line">Available arguments:</div>
</div><!-- fragment --><p> 'robot_name': Options: husky (default: 'husky')</p>
<p>'world_file_name': Options: cave_circuit, urban_circuit_practice_03 (default: 'cave_circuit')</p>
<p>'use_joystick': Use a real joystick. (default: 'False')</p>
<p>'joy_config_file': Full path to the joy config (default: 'joy_config_file')</p>
<p>'teleop_twist_config_file': Full path to the teleop twist joy config (default: 'teleop_twist_config_file') </p><div class="fragment"><div class="line">In a new terminal, source your workspace and start SLAM. Remap the node scanmatcher&#39;s topic `/input_cloud` to `/husky/scan/points` in the `lidarslam.launch.py`</div>
</div><!-- fragment --><p> ros2 launch lidarslam lidarslam.launch.py main_param_dir:=/path/to/your/lidarslam.yaml </p><div class="fragment"><div class="line">In a new terminal, source your workspace, ugv_nav4d library, and launch the ugv_nav4d_ros2. Replace the /path/to/your/ugv_nav4d with the location of the ugv_nav4d library. Add this command to your terminal:</div>
</div><!-- fragment --><p> source ~/your_ros2_workspace/install/setup.bash source /path/to/your/ugv_nav4d/build/install/env.sh</p>
<p>ros2 launch ugv_nav4d_ros2 ugv_nav4d.launch.py pointcloud_topic:=/map goal_topic:=/goal_pose </p><div class="fragment"><div class="line">In a new terminal, start a python script to visualize the labeled path in rviz2.</div>
</div><!-- fragment --><p> cd ~/your_ros2_workspace/src/ugv_nav4d_ros2/scripts python3 visualize_path.py </p><div class="fragment"><div class="line">In a new terminal, start Rviz2.</div>
</div><!-- fragment --><p> cd ~/your_ros2_workspace source ~/your_ros2_workspace/install/setup.bash source /path/to/your/ugv_nav4d/build/install/env.sh rviz2 -d src/ugv_nav4d_ros2/config/ugv_nav4d.rviz </p><div class="fragment"><div class="line">After you start to move the robot, the planner will show the following status:</div>
</div><!-- fragment --><p> [ugv_nav4d_ros2]: Planner state: Got Map [ugv_nav4d_ros2]: Initial patch added. [ugv_nav4d_ros2]: Planner state: Ready </p><div class="fragment"><div class="line">Visualize the MLS in Rviz2 using </div>
</div><!-- fragment --><p> ros2 service call /ugv_nav4d_ros2/map_publish std_srvs/srv/Trigger </p><div class="fragment"><div class="line">![MLSVizRviz2](doc/figures/mls_visualization_rviz2.png)</div>
<div class="line"> </div>
<div class="line">The gaps in the MLS map are due to the gaps in the scanned points. Move the robot around in the environment. After some time, you will see the MLS start to fill out the gaps.</div>
<div class="line"> </div>
<div class="line">![MLSVizRviz2](doc/figures/mls_visualization_rviz2_2.png)</div>
<div class="line"> </div>
<div class="line">Set a goal using the `2D Goal Pose` option in Rviz2 or by publishing to the topic `/ugv_nav4d_ros2/goal_pose`.</div>
<div class="line"> </div>
<div class="line">![GoalPose2D](doc/figures/set_goal_pose_rviz2.png)</div>
</div><!-- fragment --><p> ros2 topic pub /goal_pose geometry_msgs/PoseStamped "{header: {stamp: {sec: 0, nanosec: 0}, frame_id: 'map'}, pose: {position: {x: 4.0, y: 4.0, z: 0.0}, orientation: {x: 0.0, y: 0.0, z: 0.0, w: 1.0}}}" </p><div class="fragment"><div class="line">#### cave_circuit</div>
<div class="line"> </div>
<div class="line">![MLSVizRviz2](doc/figures/mls_visualization_rviz2_3.png)</div>
<div class="line"> </div>
<div class="line">If planning is successful you should see the following status in the terminal:</div>
</div><!-- fragment --> <div class="fragment"><div class="line">#### urban_circuit_practice_03</div>
<div class="line">You could repeat the same steps and in Step 6 set `world_file_name:=urban_circuit_practice_03`.</div>
<div class="line"> </div>
<div class="line">![MLSVizRviz2](doc/figures/mls_visualization_rviz2_4.png)</div>
<div class="line"> </div>
<div class="line">---</div>
<div class="line">## Implementation Details</div>
<div class="line">### Planning</div>
<div class="line">The planner is based on SBPL (http://www.sbpl.net/). I.e. it uses the SBPLs ARA* planner to plan in a custom environment.</div>
<div class="line"> </div>
<div class="line">#### Environment</div>
<div class="line">SBPL internally uses states (identified by an id only) and associated costs (a unitless integer). The state ids reference states of an environment. That environment has to be defined by the user.</div>
<div class="line">The planner contains the `EnvironmentXYZTheta`. This environment implements all interfaces needed by SBPL to enable ARA* planning (other planning algorithms might require additional interfaces).</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">A state in this environment consists of the position on the map (xyz) and the orientation of the robot (theta), hence the name. </div>
<div class="line"> </div>
<div class="line">The mapping `idToHash` in `EnvironmentXYZTheta` maps the SBPL state ids to instances of `Hash` (our internal representation of a state).</div>
</div><!-- fragment --><p> struct Hash { XYZNode *node; ThetaNode *thetaNode; }; </p><div class="fragment"><div class="line">The `Hash` represents a complete planner state. It consists of an `XYZNode` and a `ThetaNode`. The `XYZNode` represents a position on the traversability map while the `ThetaNode` holds the discretized orientation. Together they form a planner state. One `XYZNode` can be part of several states (with different `ThetaNodes`). However, a new `ThetaNode` is created for each state.</div>
<div class="line">The `XYZNode` contains a map to all `ThetaNodes` that it has been associated with during planning. </div>
<div class="line"> </div>
<div class="line">All `XYZNodes` are part of the `searchGrid`.</div>
<div class="line">An `XYZNode` is always created from (and corresponds to) a `TravGenNode` and shares the `TravGenNodes` index. I.e. the `XYZNodes` position in the `searchGrid` is the same as the `TravGenNodes` position on the `traversabilityMapGenerator::travMap`. For easy access the `XYZNode` contains a pointer to the corresponding `TravGenNode`.</div>
<div class="line"> </div>
<div class="line">The `searchGrid` keeps track of the internal state while planning. It contains an `XYZNode` for every grid cell that the planner has already visited.</div>
<div class="line">The `searchGrid` is a `TraversabilityMap` but the traversability information is not used (and never set).</div>
<div class="line">The `TraversabilityMap` was chosen because it enables O(n) (n &lt;= maximum number of layers in the map) lookup of nodes based on their xyz position. The choice was made due to time constraints (the map was there and it worked and there was no time). Semantically the usage of a `TraversabilityMap` to store the `XYZNodes`is wrong and it should be changed (e.g. to a hashmap), but it works and thus was never changed.</div>
<div class="line"> </div>
<div class="line">#### The `TraversabilityMap`</div>
<div class="line">In addion to the `searchGrid` the environment has access to a `TraversabilityMap3D` (accessed through the `travGen` attribute).</div>
<div class="line"> </div>
<div class="line">A `TraversabilityMap3D` is generated from an MLS and separates the MLS into traversable, non-traversabel and unknown terrain. Addtionally it contains some meta data (e.g. slope of the patch, supporting plane, etc.).</div>
<div class="line">The map is generated by the `TraversabilityMapGenerator` based on a set of rules.</div>
<div class="line"> </div>
<div class="line">The `TraversabilityMap3D` has to be fully expanded (i.e. generated from the MLS) before planning. In theory it could be expanded on the fly during planning and the code is prepared to do that, however this was never tested and there is a good chance that on-the-fly expansion will trigger bugs (especially if parallelism is enabled).</div>
<div class="line"> </div>
<div class="line">The planner uses the `TraversabilityMap3D` to find valid successor states during planning. I.e. states that the robot can traverse to from a given state using the given motion primitives. Metadata stored in the map (e.g. slope) is also used during planning to calculate costs.</div>
<div class="line"> </div>
<div class="line">#### Color Codes</div>
<div class="line"> </div>
<div class="line">![ColorCodes](doc/figures/color_codes.png)</div>
<div class="line"> </div>
<div class="line">The visualizer of the `TraversabilityMap3D` uses color coding to indicate the different patch types:</div>
<div class="line">- **Traversable**: The robot can stand (with its center) on this patch in at least one orientation without hitting an obstacle.</div>
<div class="line">- **Not Traversable**: There is no way that the robot can stand (with its center) on this patch.</div>
<div class="line">- **Frontier**: Borders to the end of the map. Should be traversable (I am not 100% sure about this. check the code!)</div>
<div class="line">- **Unknown**: This is a virtual patch that serves as boundary for algorithms. This patch does not exist in reality. Patches also become unknown if there is not enough support in the MLS to be sure that a patch exists in this location.</div>
<div class="line">- **Hole**: This is part of the map specification but is not used by ugv_nav4d. It might be used elsewhere but the planner cannot handle it.</div>
<div class="line">- **Unset**: This is the starting state of a new patch. It should not be visible in a fully explored map. If you see a yellow patch after map expansion is done, you have found a bug in the `TraversabilityMapGenerator` and should investigate.</div>
<div class="line"> </div>
<div class="line">![TravMap1](doc/figures/trav_map_1.png)</div>
<div class="line"> </div>
<div class="line">#### Obstacle Checking</div>
<div class="line">To ensure that the robot can traverse a certain area, obstacle checks have to be done.</div>
<div class="line">If we would have infinite resources we could just collide the robot model with the MLS for every possible state and see if it collides or not.</div>
<div class="line">But since we have very limitted resources we cannot do that. Instead there are several obstacle checking phases:</div>
<div class="line"> </div>
<div class="line">##### 1. Obstacle Checks done during Expansion of the `TraversabilityMap3D`</div>
<div class="line">All obstacle checks in this phase are done using the rotation invariant bounding box of the robot. This is an axis aligned bounding box with side length `min(config.robotSizeX, config.robotSizeY)`. With this check when an a patch is an obstacle we are 100% sure that it is. But if it is not we cannot be sure that it is not. This greatly reduces map size and planning time without costing too much as checks are only done once per patch.</div>
<div class="line">It also means that a full 3D oriented bounding box check is still necessary during planning to factor in different side lengths and the orientation of the robot.</div>
<div class="line"> </div>
<div class="line">- **Step height check**: A patch is an obstacle if the height between the patch and its neighbors is higher than the maximum step height of the robot. If the robot would stand on this patch, the neighboring patch would be inside the robots body. </div>
<div class="line">- **Slope check**: A patch is an obstacle if the slope of the patch is above the slope limit.</div>
<div class="line">- **Map limit check**: A patch is an obstacle if the bounding box of the robot (again just using the smaller side length) leaves the map (maximum possible map, not currently known map).</div>
<div class="line"> </div>
<div class="line">I.e. this step marks patches in the `TraversabilityMap3D` as obstacle if the robot would touch an obstacle when standing (centered) on this patch, or when the slope is too steep.</div>
<div class="line"> </div>
<div class="line">##### 2. The `ObstacleMap`</div>
<div class="line">The `ObstacleMap` is a `TraversabilityMap3D` and is created by the `ObstacleMapGenerator`.</div>
<div class="line">The generator shares a lot of code with the `TraversabilityMapGenerator`. It differs only in how obstacle checks are done, i.e. what patches are marked as obstacles.</div>
<div class="line"> </div>
<div class="line">Patches are marked as obstacle if there is a patch above the marked patch and below robot height. I.e. if the robot would stand on this patch, the patch above would be inside the robot.</div>
<div class="line">This is a tiny but important difference. It means that, if the robot is on this patch with even a tiny bit of its body, it would touch an obstacle.</div>
<div class="line"> </div>
<div class="line">Using the obstacle map, the 3D collision test (that is necessary during planning) is reduced to a 2D oriented bounding box test. This is the only reason for the existence of the obstacle map. It reduces the complexity of the 3D collison check to 2D. Basically the height check is pre-computed for each patch and stored in the obstacle map. </div>
<div class="line"> </div>
<div class="line">The `ObstacleMap` is used during planning to check if the robot would hit an obstacle when moving to a certain state. </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">#### Heuristic</div>
<div class="line">ARA* is a real-timeish version of A*. Thus it needs a heuristic.</div>
<div class="line"> </div>
<div class="line">The heuristic h(a,b) between two cells a and b is the time it would take the robot to follow the shortest path from a to b on the TraversabilityMap3D. The shortest path is calculated ***without*** taking any of the following into account:</div>
<div class="line">- the robot dimensions and orientation (The minimum bounding box has already been checked while expanding the map)</div>
<div class="line">- collision checks on the ObstacleMap</div>
<div class="line">- steepness of the terrain (i.e. as long as a patch has a steepness below the limit the costs are the same)</div>
<div class="line">- motion primitives</div>
<div class="line">- motion restrictions of the robot</div>
<div class="line"> </div>
<div class="line">I.e. it is the path that the robot would be able to follow if it was infinitesimal small and could change direction instantly. </div>
<div class="line"> </div>
<div class="line">The heuristic is computed beforehand for all nodes of the map. Changing the code to on-demand heuristic should be possible. It was not done because it was not needed (fast enough for our maps) at the time of writing.</div>
<div class="line"> </div>
<div class="line">SBPL expects the heuristic to be an integer. To avoid losing precision when converting to int the heuristic value is scaled by `Motion::costScaleFactor` (usually 1000) before conversion. Without the scaling small movements have no cost at all.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">#### Motion Primitives</div>
<div class="line">The planner uses motion primitives, a set of pre-defined small motions, to determine how the robot can move from one state to the next.  The primitives are classified into four categories, namely:</div>
<div class="line"> </div>
<div class="line">**Forward Primitive**</div>
<div class="line">**Backward Primitive**</div>
<div class="line">**Lateral Primitive**</div>
<div class="line">**Point-Turn Primitive**</div>
<div class="line"> </div>
<div class="line">All four primitive motion types are considered as valid motions. It needs to be mentioned that the point-turn primitives are a special case because they do not use a spline. On the contrary, forward, backward, and lateral motion primitives are splines. </div>
<div class="line"> </div>
<div class="line">The basic shapes of the motion primites are generated by the `SbplSplineMotionPrimitives` library.</div>
<div class="line">The library generates primitives using splines based on a few parameters in a perimeter around the robot.</div>
<div class="line"> </div>
<div class="line">The parameters for primitive generation are grouped in the `SplinePrimitivesConfig` class.</div>
<div class="line"> </div>
<div class="line">- `gridSize` - The width/height of a grid cell of the planning grid. This should be the same as the resolution of the map. Available end positions will be a multiple of this.</div>
<div class="line">- `numAngles` - The number of discrete start orientations. A full set of primitives will be generated for each orientation.</div>
<div class="line">- `numEndAngles` - The maximum number of end orientation. For each start orientation and each end orientation a full set of primitives will be generated. This is an upper boundry. It might not be reached.</div>
<div class="line">- `destinationCircleRadius` - Radius around the robot (in cells) that primitives will be generated for.</div>
<div class="line">- `cellSkipFactor` - Sparseness of the generated primitives.</div>
<div class="line">- `splineOrder` Order of the generated splines.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">Based on the value of the parameter `destinationCircleRadius` a number of discrete destination points are generated on concentric circles. The parameter `CellSkipFactor` decides the interval between each two consecutive concentric circles. Before generating a motion primitive, each destination cell is scaled via multiplication with the `gridSize`. A unique motion primitives is generated for each start angle to each destination cell shown in picture below, from `(0,0)` to that cell for each end angle. The number of start angles and end angles is decided basd on the parameters `numAngles` and `numEndAngles` respectively.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">![NumAngles](doc/figures/num_angles.png)</div>
<div class="line"> </div>
<div class="line">To keep the number of primitives reasonable they are discretized. Their start and end positions are discretized using a 2d grid. The start and end orientations are discretized using angle segments.</div>
<div class="line"> </div>
<div class="line">![NumAngles](doc/figures/splines.gif)</div>
<div class="line"> </div>
<div class="line">This animation shows all splines generated by the following configuration (each frame shows the primitives for one start orientation). </div>
</div><!-- fragment --><p> config.gridSize = 0.1; config.numAngles = 24; config.numEndAngles = 12; config.destinationCircleRadius = 5; config.cellSkipFactor = 1.0; config.generatePointTurnMotions = false; config.generateLateralMotions = false; config.generateBackwardMotions = false; config.generateForwardMotions = true; config.splineOrder = 4; </p><div class="fragment"><div class="line">##### Default Parameters</div>
<div class="line">| Parameter | Type |Description | Recommented Value |</div>
<div class="line">|-----------------|:-------------|:-------------|:-------------|</div>
<div class="line">| dumpOnError | bool  | Refer to the section  `Dumping Planner State`  | Release: 0, Debug: 1  |</div>
<div class="line">| dumpOnSuccess    | bool         | Refer to the section `Dumping Planner State`  | Release: 0, Debug: 1 |</div>
<div class="line">| initialPatchRadius     | double        | Radius of initial patch of point cloud points to kick-start the planner  | 3.0 |</div>
<div class="line"> </div>
<div class="line">##### Mobility Configuration Parameters</div>
<div class="line">| Parameter | Type |Description |Recommented Value |</div>
<div class="line">|-----------------|:-------------|:-------------|:-------------|</div>
<div class="line">| translationSpeed | double  | Linear velocity of the resulting path trajectory  | 1.0 |</div>
<div class="line">| rotationSpeed    | double         | Angular velocity of the resulting path trajectory  | 1.0 |</div>
<div class="line">| minTurningRadius     | double        | The minimum turning radius corresponds to the maximum curvature. This parameter therefore helps to select all motion primitives which have curvature less than the maximum curvature. A higher value means less cap for the maximum curvature resulting in linear primitives. A small value will result in more curvy primitives. Note that a smaller value results in more primitives selected which requires more computation power for the planning. For details see section `Minimum Turning Radius`  | 0.1 |</div>
<div class="line">| multiplierForward | int  | Cost multiplier for the forward motion primitives  | 1 |</div>
<div class="line">| multiplierBackward    | int         | Cost multiplier for the backward motion primitives  | 2 |</div>
<div class="line">| multiplierLateral     | int        | Cost multiplier for the lateral motion primitives  | 2 |</div>
<div class="line">| multiplierForwardTurn | int  | Cost multiplier for the forward turn motion primitives  | 1 |</div>
<div class="line">| multiplierBackwardTurn    | int         | Cost multiplier for the backward turn motion primitives  | 2 |</div>
<div class="line">| multiplierPointTurn     | int        | Cost multiplier for the point turn motion primitives  | 1 |</div>
<div class="line">| multiplierLateralCurve | int  | Cost multiplier for the lateral curve motion primitives  | 2 |</div>
<div class="line">| searchRadius    | double         |   | 1.0 |</div>
<div class="line">| searchProgressSteps     | double        |   | 0.1 |</div>
<div class="line">| remove_goal_offset     | bool        | Remove the goal offset which is there because of the discretization  | true |</div>
<div class="line">| spline_sampling_resolution     | double        | Resolution used to sample the motion primitive spline  | 0.01 |</div>
<div class="line">| maxMotionCurveLength | double  | The maximum curve length of the selected motion primitives. Small value results in small primitives and a large value results in longer primitives. During testing, it was observed that the planner has a hard time in finding a solution if the value of this parameter is set &lt; 0.6  | 1.3 |</div>
<div class="line"> </div>
<div class="line">##### Planner Configuration Parameters</div>
<div class="line">| Parameter | Type |Description | Recommented Value |</div>
<div class="line">|-----------------|:-------------|:-------------|:-------------|</div>
<div class="line">| initialEpsilon | int  | The planner uses ARA* planner. It finds a sub-optimal solution and then repairs the initial solution by using reducing the epsilon by the parameter `epsilonSteps`. An optimal solution means epsilon is equal to 1, where `solution = epsilon x optimal_solution`   | 36  |</div>
<div class="line">| epsilonSteps    | int         | The steps in the epsilon during planning and repairing of the initial sub-optimal solution  | 6 |</div>
<div class="line">| numThreads     | int        | A limit on the threads allocated for the planner during planning.  | 8|</div>
<div class="line">| usePathStatistics     | bool        | Should a computationally expensive obstacle check be done to check whether the robot bounding box is in collision with obstacles. This mode is useful for highly cluttered and tight spaced environments.  | false|</div>
<div class="line">| searchUntilFirstSolution     | bool        | Search only until the first solution and then stop planning. See SBPL documentation for an explantion of this value.  | false |</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">##### Primitives Configuration Parameters</div>
<div class="line">| Parameter | Type |Description | Recommented Value |</div>
<div class="line">|-----------------|:-------------|:-------------|:-------------|</div>
<div class="line">| gridSize | double  | The size of the traversability map grid  | Use case specific |</div>
<div class="line">| numAngles    | int         | number of discrete start angles angles. A full set of primitives will be generated for each start angle (has to be even number). For best performance, the value should be a multiple of 4. The multiple of 4 means that correct lateral motion primitives are generated. The reason for this is that the lateral motions are seen as 90 degree rotated motions from any given start angle. For this, the start angle is divided by 4 (because of 4 quadrants) and the result is subracted from the start angle  | 40 |</div>
<div class="line">| numEndAngles     | int        | The number of end angles for each destination cell. The value has to be &lt;= numAngles/2 and odd | 9|</div>
<div class="line">| destinationCircleRadius     | int        | See section `Motion Primitives`  | 6 |</div>
<div class="line">| cellSkipFactor     | int        | See section `Motion Primitives`. It is best to leave this value at &gt;= 1 in integer steps. A value of less than 1 results in duplicate destination cells and do not add any value to the planning  | 1 |</div>
<div class="line">| splineOrder     | int        | The value has to be &gt;= 3  | 3.0 |</div>
<div class="line">| generateForwardMotions     | bool        | Generate forward motion primitives. Forward primitives are for the case where destination cell x-coordinate &gt; 0.1 |  Use case specific |</div>
<div class="line">| generateBackwardMotions     | bool        | Generate backward motion primitives. Backward primitives are for the case where destination cell x-coordinate &lt; -0.1  |  Use case specific |</div>
<div class="line">| generateLateralMotions     | bool        | Generate lateral motion primitives. Lateral primitives are for the case where the destination cell x-coordinate &gt; -0.1 and destination cell x-coordinate &lt; 0.1  |  Use case specific|</div>
<div class="line">| generatePointTurnMotions     | bool        | Generate point-turn motion primitives. A point-turn is generated for each start angle to each end angle  |  Use case specific |</div>
<div class="line"> </div>
<div class="line">##### Traversability Configuration Parameters</div>
<div class="line">| Parameter | Type |Description | Recommented Value |</div>
<div class="line">|-----------------|:-------------|:-------------|:-------------|</div>
<div class="line">| maxStepHeight | double  | The maximum step height that the robot can traverse. This is used during map expansion. Steps heigher than this become map boundaries   | Use case specific  |</div>
<div class="line">| maxSlope    | double         | Maximum traversable slope above which no travmap entries will be generated | 0.45 |</div>
<div class="line">| inclineLimittingMinSlope     | double        |   | 0.2 |</div>
<div class="line">| inclineLimittingLimit | double  |  | 0.1 |</div>
<div class="line">| costFunctionDist    | double         | Objects within a corridor of width costFunctionDist around a trajectory will influence the cost function. A higher value results in large computation cost requirements for the planning.  | 0.0 |</div>
<div class="line">| minTraversablePercentage     | double        | This value controls, how unknown patches are detected. If only a certain percentage of MSL patches are present on the surface of a traversability patch, it is rated as an unknown patch.    | 0.4 |</div>
<div class="line">| robotHeight | double  |  | Use case specific  |</div>
<div class="line">| robotSizeX    | double         | The length of the robot along x-axis   | Use case specific |</div>
<div class="line">| robotSizeY     | double        | The length of the robot along y-axis| Use case specific |</div>
<div class="line">| distToGround | double  | Distance from body frame to ground. Start and goal position are expected in body frame  | Use case specific  |</div>
<div class="line">| slopeMetricScale    | double         |   | 1.0 |</div>
<div class="line">| slopeMetric     | double        | The slope metric used to adjust the cost of a motion | Use case specific |</div>
<div class="line">| gridResolution | double  | The resolution of the traversability grid map  | Use case specific |</div>
<div class="line">| initialPatchVariance    | double         |   | 0.0001|</div>
<div class="line">| allowForwardDownhill     | bool        |   | true |</div>
<div class="line">| enableInclineLimitting | bool  |  | false  |</div>
<div class="line"> </div>
<div class="line">##### Motion Primitive Filtering</div>
<div class="line"> </div>
<div class="line">###### Minimum Turning Radius</div>
<div class="line">The planner filters the primitives by `minTurningRadius` (i.e. all primitives that have a curvature that is larger than allowed by the minimum turning radius are ignored)</div>
<div class="line"> </div>
<div class="line">The following animation shows the same primitives as above but filtered with a `minTurningRadius` of `0.2`:</div>
<div class="line"> </div>
<div class="line">![SplinesFiltered](doc/figures/splines_filtered.gif)</div>
<div class="line"> </div>
<div class="line">As you can see all sharp turns have been removed from the splines.</div>
<div class="line"> </div>
<div class="line">After filtering the splines are sampled using the planning grid resolution and the base cost for each motion is calculated. The sampled positions are later used during planning.</div>
<div class="line"> </div>
<div class="line">If your environment contains tight spots it is recommended to enable `generateBackwardMotions`. Otherwise the planner will have a hard time finding solutions to get to the correct end orientation in tight spots.</div>
<div class="line"> </div>
<div class="line">###### Maximum Curve Length</div>
<div class="line">You can filter the primitives using the parameter `maxMotionCurveLength`. All primitives which have a curve length less than the `maxMotionCurveLength` will be selected.</div>
<div class="line"> </div>
<div class="line">The figure below shows the complete set of discritized splines, **without any curve length filter applied**, generated for the start angle of 0 radians. The green color signifies discritized primitives for forward motion, magenta for backward motion, and orange for lateral motion. Please note that the point-turns do not have a spline and therefore are not visible in the image below.</div>
<div class="line"> </div>
<div class="line">![MaxCurveLength](doc/figures/max_curve_length.png)</div>
<div class="line"> </div>
<div class="line">The figure below shows the same set of discritized splines for start angle of 0 radians but with a `maxMotionCurveLength` of 1.2.</div>
<div class="line"> </div>
<div class="line">![MaxCurveLength2](doc/figures/max_curve_length_2.png)</div>
<div class="line"> </div>
<div class="line">To get an idea about different geometric lengths of the primitives see the picture below. The picture shows only forward and backward motion primitives. Each arrow represents the end of a unqiue primitive. As mentioned earlier, the end points of the primitives are the destination cells scaled by the grid size of the traversability map. </div>
<div class="line"> </div>
<div class="line">![MaxCurveLength3](doc/figures/max_curve_length_3.png)</div>
<div class="line"> </div>
<div class="line">##### Motions</div>
<div class="line">Each slected motion primitive is converted into a motion. A motion is a discritized motion primitive. In the planning phase, each discrete step of the motion is used to perform traversability and obstacle checks. You can find details on the motions in the class preComputedMotions.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">##### Motion Base Cost Calculation</div>
<div class="line">Upon motion generation every motion is asigned a base cost.</div>
<div class="line">I.e. the cost that would arise when the robot would follow that motion on a horizontal flat surface.</div>
<div class="line">Factors for steepness and other penalties might be factored later during planning on a case to case basis.</div>
<div class="line"> </div>
<div class="line">The base cost for each motion is calculated as follows:</div>
</div><!-- fragment --><p> translationDist = &lt; distance that the robot has to travel while following the spline &gt; rotationDist = &lt; amount that the robot has to turn while following the spline &gt; translationTime = translationalDist / translationVelocity rotationTime = rotationDist / angularVelocity travelTime = max(rotationTime, translationTime) costMultiplier = &lt; the configured multiplier for this particular motion type &gt; baseCost = int(ceil(travelTime * 1000 * costMultiplier)) </p><div class="fragment"><div class="line">The travelTime is scaled by 1000 to retain three digits of precision when converting to integer.</div>
<div class="line"> </div>
<div class="line">##### Motion Cost Scaling</div>
<div class="line"> </div>
<div class="line">Since all primitives are 2-dimensional the `baseCost` is only accurat on perfectly flat terrain. To factor in the slope of the terrain the cost is scaled based on one of the following metrics during planning.</div>
<div class="line"> </div>
<div class="line">###### SlopeMetric::NONE</div>
</div><!-- fragment --><p> cost = motion.baseCost; </p><div class="fragment"><div class="line">###### SlopeMetric::AVG_SLOPE</div>
</div><!-- fragment --><p> slopeFactor = &lt; avg slope under spline&gt; * config.slopeMetricScale; cost = motion.baseCost + motion.baseCost * slopeFactor; </p><div class="fragment"><div class="line">###### SlopeMetric::MAX_SLOPE</div>
</div><!-- fragment --><p> slopeFactor = &lt; max slope under spline&gt; * config.slopeMetricScale; cost = motion.baseCost + motion.baseCost * slopeFactor; </p><div class="fragment"><div class="line">###### SlopeMetric::TRIANGLE_SLOPE</div>
<div class="line">This one is a little tricky. </div>
<div class="line">We take the length of the spline and project it onto the slope between the start and end position. Then we measure the length of the projected line and use that to re-calculate the cost using the base cost formula (see above). This should give a good approximation of the real travel time needed to move up (or down) a slope.</div>
</div><!-- fragment --><p> heightDiff = &lt; height difference between start and end of motion &gt; approxMotionLen = sqrt(motion.translationlDist^2 + heightDiff^2) cost = calculateCost(approxMotionLen) ```</p>
<p>None of those metrices captures the real cost of moving up or down a slope. They have been implemented for experimentation. However those experiments have never been done (we ran out of time and there where no slopes in the final demo). Thus the performance of the metrices is unclear.</p>
<h4><a class="anchor" id="autotoc_md10"></a>
Dumping Planner State</h4>
<p>In case of error the <code>Planner</code> dumps its state to a file (this can be enabled using the <code>dumpOnError</code> parameter). The state can be loaded and analyzed using the <code>ugv_nav4d_replay</code> binary. This binary loads the state and executes the planning in a controlled environment. This can be used to debug the planner.</p>
<h4><a class="anchor" id="autotoc_md11"></a>
User Interfaces</h4>
<p>Two user interfaces can be found in <code>src/gui</code>. They are intended for testing and debugging.</p>
<p><a class="anchor" id="autotoc_md12"></a> </p><h5><a class="el" href="classPlannerGui.html">PlannerGui</a></h5>
<p>The <code><a class="el" href="classPlannerGui.html">PlannerGui</a></code> is the main testing gui. It is designed to experiment with differen planner parameters on a static map. It can load point clouds from ply or serialized mls maps. A left click sets the start location, a right click sets the end location.</p>
<p>In addition the <code><a class="el" href="classPlannerGui.html">PlannerGui</a></code> can also be used to load and analyze planner dumps.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Bug Reports</h2>
<p>To search for bugs or report them, please use GitHubs <a href="https://github.com/dfki-ric/ugv_nav4d/issues">Issue-Tracker</a> </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
