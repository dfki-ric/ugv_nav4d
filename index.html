<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ugv_nav4d: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ugv_nav4d
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">ugv_nav4d Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> CI build and test:</p>
<p>Main: <img src="https://github.com/dfki-ric/ugv_nav4d/actions/workflows/c-cpp.yml/badge.svg" alt="Main" style="pointer-events: none;" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md0"></a>
Advanced Multi-Surface Navigation for Unmanned Ground Vehicles (UGVs) Using 4D Path Planning Techniques (ugv_nav4d)</h1>
<p>A 4D (X,Y,Z, Theta) Planner for unmaned ground vehicles (UGVs).</p>
<p>&lt;figure&gt; <img src="doc/figures/ugv_nav4d_logo.jpeg" alt="" height="200" width="200" class="inline"/> &lt;/figure&gt;</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Installation</h2>
<p>Follow the steps to peform a standalone build of the library.</p>
<h3><a class="anchor" id="autotoc_md2"></a>
System Requirements</h3>
<div class="fragment"><div class="line">OS: Ubuntu 20.04, Ubuntu 22.04 (Recommended)</div>
</div><!-- fragment --><p> See <a href="source_dependencies/install_os_dependencies.bash">install_os_dependencies.bash</a> for further os dependencies.</p>
<h4><a class="anchor" id="autotoc_md3"></a>
Get the library</h4>
<div class="fragment"><div class="line">git clone https://github.com/dfki-ric/ugv_nav4d.git</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md4"></a>
Automatic Install of Dependencies &amp; Build</h4>
<p>Install dependencies automatically when building <a class="el" href="namespaceugv__nav4d.html">ugv_nav4d</a>. Defining <code>-DINSTALL_DEPS=ON</code> for cmake, builds and installs the source dependencies automatically. When <code>-DCMAKE_INSTALL_PREFIX</code> is used, the dependencies are also installed there. The install script generates an env.sh file in the <code>CMAKE_INSTALL_PREFIX</code> folder. It exports all neccessary environment variables.</p>
<div class="fragment"><div class="line">cd ugv_nav4d</div>
<div class="line">mkdir build &amp;&amp; cd build</div>
<div class="line">cmake -DINSTALL_DEPS=ON -DCMAKE_INSTALL_PREFIX=./install ..</div>
<div class="line">make install</div>
<div class="line">source install/env.sh</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md5"></a>
Manual Installation of Dependencies &amp; Build</h4>
<p>Skip this step if you already installed the dependencies automatically from the previous step.</p>
<p>Follow the steps to manually install dependencies. Define a path_to_install_folder e.g. <code>./install</code> where the dependencies will be installed</p>
<div class="fragment"><div class="line">cd ugv_nav4d</div>
<div class="line">mkdir build &amp;&amp; cd source_dependencies</div>
<div class="line">bash ./install_os_dependencies.bash</div>
<div class="line">bash ./build.bash ../build/install</div>
</div><!-- fragment --><p>After all dependencies have been installed. Go back to the main folder to build and install <a class="el" href="namespaceugv__nav4d.html">ugv_nav4d</a> like any other cmake project.</p>
<div class="fragment"><div class="line">cd ../build</div>
<div class="line">source install/env.sh</div>
<div class="line">cmake -DCMAKE_INSTALL_PREFIX=./install -DTESTS_ENABLED=OFF -DENABLE_DEBUG_DRAWINGS=OFF -DCMAKE_BUILD_TYPE=RELEASE ..</div>
<div class="line">make install</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md6"></a>
Compiling inside a ROCK environment [Only for ROCK users]</h4>
<p>See the <code>manifest.xml</code> for an up to date list of dependencies. If you are ROCK user then include the package_set which contains the <code>dfki-ric/orogen-ugv_nav4d</code> package in your autoproj manifest file.</p>
<h4><a class="anchor" id="autotoc_md7"></a>
Generate API Documentation</h4>
<p>The API documentation is generated based on doxygen. You do not need to install doxygen because it is installed as part of the <code>install_os_dependencies.bash</code> script used in the previous step.</p>
<p>You just need to run the <code>make doc</code> command in the <a class="el" href="namespaceugv__nav4d.html">ugv_nav4d</a> build folder. The doxygen documentation will be automatically generated in the <code>build/doc</code> folder.</p>
<div class="fragment"><div class="line">cd build/</div>
<div class="line">make doc</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md8"></a>
GUI Usage &amp; Tests</h4>
<p>Source the <code>env.sh</code> in the install folder.</p>
<p>At first, get the test point cloud maps and start the GUI. </p><div class="fragment"><div class="line">cd ..</div>
<div class="line">git lfs pull</div>
<div class="line">source build/install/env.sh</div>
<div class="line">ugv_nav4d_bin-qt5 test_data/parking_deck.ply 0.3</div>
</div><!-- fragment --><p> <img src="doc/figures/planner_gui.png" alt="PlannerGui" class="inline"/></p>
<p>A basic GUI is loaded with the Multi-layer Surface Map of a parking deck environment. Use the mouse left-click to select a start position and the mouse right-click to select the goal position. The sliders can be used to changed the orientations of start and goal positions. Click on the button <code>Plan</code> to plan a path.</p>
<p><img src="doc/figures/planner_gui_result.png" alt="PlannerGuiResult" class="inline"/></p>
<p>The button <code>Create PlannerDump</code> can be used to save the planner's state. The created file e.g. ugv4d_dump_xxxx.bin can be replayed using the executable <code>ugv_naved_replay</code>.</p>
<div class="fragment"><div class="line">ugv_nav4d_replay ugv4d_dump_xxxx.bin</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md9"></a>
Unit Tests</h4>
<p>Build the library again but this time enable the <code>-DTESTS_ENABLED=ON</code></p>
<div class="fragment"><div class="line">cd build</div>
<div class="line">cmake -DCMAKE_INSTALL_PREFIX=./install -DTESTS_ENABLED=ON -DENABLE_DEBUG_DRAWINGS=OFF -DCMAKE_BUILD_TYPE=RELEASE ..</div>
<div class="line">make install</div>
</div><!-- fragment --><p> Run the unit tests using the executable </p><div class="fragment"><div class="line">test_ugv_nav4d ../test_data/Plane1Mio.ply</div>
</div><!-- fragment --><p>At the end you should see the output </p><div class="fragment"><div class="line">[----------] Global test environment tear-down</div>
<div class="line">[==========] 6 tests from 2 test suites ran. (10297 ms total)</div>
<div class="line">[  PASSED  ] 6 tests.</div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="autotoc_md11"></a>
Implementation Details</h2>
<h3><a class="anchor" id="autotoc_md12"></a>
Planning</h3>
<p>The planner is based on SBPL (<a href="http://www.sbpl.net/">http://www.sbpl.net/</a>). I.e. it uses the SBPLs ARA* planner to plan in a custom environment.</p>
<p>TODO parallellism</p>
<h4><a class="anchor" id="autotoc_md13"></a>
Environment</h4>
<p>SBPL internally uses states (identified by an id only) and associated costs (a unitless integer). The state ids reference states of an environment. That environment has to be defined by the user. The planner contains the <code>EnvironmentXYZTheta</code>. This environment implements all interfaces needed by SBPL to enable ARA* planning (other planning algorithms might require additional interfaces).</p>
<p>A state in this environment consists of the position on the map (xyz) and the orientation of the robot (theta), hence the name.</p>
<p>The mapping <code>idToHash</code> in <code>EnvironmentXYZTheta</code> maps the SBPL state ids to instances of <code>Hash</code> (our internal representation of a state). </p><div class="fragment"><div class="line">struct Hash</div>
<div class="line">{</div>
<div class="line">    XYZNode *node;</div>
<div class="line">    ThetaNode *thetaNode;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>Hash</code> represents a complete planner state. It consists of an <code>XYZNode</code> and a <code>ThetaNode</code>. The <code>XYZNode</code> represents a position on the traversability map while the <code>ThetaNode</code> holds the discretized orientation. Together they form a planner state. One <code>XYZNode</code> can be part of several states (with different <code>ThetaNodes</code>). However, a new <code>ThetaNode</code> is created for each state. The <code>XYZNode</code> contains a map to all <code>ThetaNodes</code> that it has been associated with during planning.</p>
<p>All <code>XYZNodes</code> are part of the <code>searchGrid</code>. An <code>XYZNode</code> is always created from (and corresponds to) a <code>TravGenNode</code> and shares the <code>TravGenNodes</code> index. I.e. the <code>XYZNodes</code> position in the <code>searchGrid</code> is the same as the <code>TravGenNodes</code> position on the <code>traversabilityMapGenerator::travMap</code>. For easy access the <code>XYZNode</code> contains a pointer to the corresponding <code>TravGenNode</code>.</p>
<p>The <code>searchGrid</code> keeps track of the internal state while planning. It contains an <code>XYZNode</code> for every grid cell that the planner has already visited. The <code>searchGrid</code> is a <code>TraversabilityMap</code> but the traversability information is not used (and never set). The <code>TraversabilityMap</code> was chosen because it enables O(n) (n &lt;= maximum number of layers in the map) lookup of nodes based on their xyz position. The choice was made due to time constraints (the map was there and it worked and there was no time). Semantically the usage of a <code>TraversabilityMap</code> to store the <code>XYZNodes</code>is wrong and it should be changed (e.g. to a hashmap), but it works and thus was never changed.</p>
<h4><a class="anchor" id="autotoc_md14"></a>
The &lt;tt&gt;TraversabilityMap&lt;/tt&gt;</h4>
<p>In addion to the <code>searchGrid</code> the environment has access to a <code>TraversabilityMap3D</code> (accessed through the <code>travGen</code> attribute).</p>
<p>A <code>TraversabilityMap3D</code> is generated from an MLS and separates the MLS into traversable, non-traversabel and unknown terrain. Addtionally it contains some meta data (e.g. slope of the patch, supporting plane, etc.). The map is generated by the <code>TraversabilityMapGenerator</code> based on a set of rules.</p>
<p>The <code>TraversabilityMap3D</code> has to be fully expanded (i.e. generated from the MLS) before planning. In theory it could be expanded on the fly during planning and the code is prepared to do that, however this was never tested and there is a good chance that on-the-fly expansion will trigger bugs (especially if parallelism is enabled).</p>
<p>The planner uses the <code>TraversabilityMap3D</code> to find valid successor states during planning. I.e. states that the robot can traverse to from a given state using the given motion primitives. Metadata stored in the map (e.g. slope) is also used during planning to calculate costs.</p>
<h4><a class="anchor" id="autotoc_md15"></a>
Color Codes</h4>
<p><img src="doc/figures/color_codes.png" alt="ColorCodes" class="inline"/></p>
<p>The visualizer of the <code>TraversabilityMap3D</code> uses color coding to indicate the different patch types:</p><ul>
<li><b>Traversable</b>: The robot can stand (with its center) on this patch in at least one orientation without hitting an obstacle.</li>
<li><b>Not Traversable</b>: There is no way that the robot can stand (with its center) on this patch.</li>
<li><b>Frontier</b>: Borders to the end of the map. Should be traversable (I am not 100% sure about this. check the code!)</li>
<li><b>Unknown</b>: This is a virtual patch that serves as boundary for algorithms. This patch does not exist in reality. Patches also become unknown if there is not enough support in the MLS to be sure that a patch exists in this location.</li>
<li><b>Hole</b>: This is part of the map specification but is not used by <a class="el" href="namespaceugv__nav4d.html">ugv_nav4d</a>. It might be used elsewhere but the planner cannot handle it.</li>
<li><b>Unset</b>: This is the starting state of a new patch. It should not be visible in a fully explored map. If you see a yellow patch after map expansion is done, you have found a bug in the <code>TraversabilityMapGenerator</code> and should investigate.</li>
</ul>
<p><img src="doc/figures/trav_map_1.png" alt="TravMap1" class="inline"/></p>
<h4><a class="anchor" id="autotoc_md16"></a>
Obstacle Checking</h4>
<p>To ensure that the robot can traverse a certain area, obstacle checks have to be done. If we would have infinite resources we could just collide the robot model with the MLS for every possible state and see if it collides or not. But since we have very limitted resources we cannot do that. Instead there are several obstacle checking phases:</p>
<p><a class="anchor" id="autotoc_md17"></a> </p><h5>1. Obstacle Checks done during Expansion of the <code>TraversabilityMap3D</code></h5>
<p>All obstacle checks in this phase are done using the rotation invariant bounding box of the robot. This is an axis aligned bounding box with side length <code>min(config.robotSizeX, config.robotSizeY)</code>. With this check when an a patch is an obstacle we are 100% sure that it is. But if it is not we cannot be sure that it is not. This greatly reduces map size and planning time without costing too much as checks are only done once per patch. It also means that a full 3D oriented bounding box check is still necessary during planning to factor in different side lengths and the orientation of the robot.</p>
<ul>
<li><b>Step height check</b>: A patch is an obstacle if the height between the patch and its neighbors is higher than the maximum step height of the robot. If the robot would stand on this patch, the neighboring patch would be inside the robots body.</li>
<li><b>Slope check</b>: A patch is an obstacle if the slope of the patch is above the slope limit.</li>
<li><b>Map limit check</b>: A patch is an obstacle if the bounding box of the robot (again just using the smaller side length) leaves the map (maximum possible map, not currently known map).</li>
</ul>
<p>I.e. this step marks patches in the <code>TraversabilityMap3D</code> as obstacle if the robot would touch an obstacle when standing (centered) on this patch, or when the slope is too steep.</p>
<p><a class="anchor" id="autotoc_md18"></a> </p><h5>2. The <code>ObstacleMap</code></h5>
<p>The <code>ObstacleMap</code> is a <code>TraversabilityMap3D</code> and is created by the <code>ObstacleMapGenerator</code>. The generator shares a lot of code with the <code>TraversabilityMapGenerator</code>. It differs only in how obstacle checks are done, i.e. what patches are marked as obstacles.</p>
<p>Patches are marked as obstacle if there is a patch above the marked patch and below robot height. I.e. if the robot would stand on this patch, the patch above would be inside the robot. This is a tiny but important difference. It means that, if the robot is on this patch with even a tiny bit of its body, it would touch an obstacle.</p>
<p>Using the obstacle map, the 3D collision test (that is necessary during planning) is reduced to a 2D oriented bounding box test. This is the only reason for the existence of the obstacle map. It reduces the complexity of the 3D collison check to 2D. Basically the height check is pre-computed for each patch and stored in the obstacle map.</p>
<p>The <code>ObstacleMap</code> is used during planning to check if the robot would hit an obstacle when moving to a certain state.</p>
<h4><a class="anchor" id="autotoc_md19"></a>
Heuristic</h4>
<p>ARA* is a real-timeish version of A*. Thus it needs a heuristic.</p>
<p>The heuristic h(a,b) between two cells a and b is the time it would take the robot to follow the shortest path from a to b on the TraversabilityMap3D. The shortest path is calculated <em><b>without</b></em> taking any of the following into account:</p><ul>
<li>the robot dimensions and orientation (The minimum bounding box has already been checked while expanding the map)</li>
<li>collision checks on the ObstacleMap</li>
<li>steepness of the terrain (i.e. as long as a patch has a steepness below the limit the costs are the same)</li>
<li>motion primitives</li>
<li>motion restrictions of the robot</li>
</ul>
<p>I.e. it is the path that the robot would be able to follow if it was infinitesimal small and could change direction instantly.</p>
<p>The heuristic is computed beforehand for all nodes of the map. Changing the code to on-demand heuristic should be possible. It was not done because it was not needed (fast enough for our maps) at the time of writing.</p>
<p>SBPL expects the heuristic to be an integer. To avoid losing precision when converting to int the heuristic value is scaled by <code>Motion::costScaleFactor</code> (usually 1000) before conversion. Without the scaling small movements have no cost at all.</p>
<h4><a class="anchor" id="autotoc_md20"></a>
Motion Primitives</h4>
<p>The planner uses motion primitives, a set of pre-defined small motions, to determine how the robot can move from one state to the next. The primitives are classified into four categories, namely:</p>
<p><b>Forward Primitive</b> <b>Backward Primitive</b> <b>Lateral Primitive</b> <b>Point-Turn Primitive</b></p>
<p>All four primitive motion types are considered as valid motions. It needs to be mentioned that the point-turn primitives are a special case because they do not use a spline. On the contrary, forward, backward, and lateral motion primitives are splines.</p>
<p>The basic shapes of the motion primites are generated by the <code>SbplSplineMotionPrimitives</code> library. The library generates primitives using splines based on a few parameters in a perimeter around the robot.</p>
<p>The parameters for primitive generation are grouped in the <code>SplinePrimitivesConfig</code> class.</p>
<ul>
<li><code>gridSize</code> - The width/height of a grid cell of the planning grid. This should be the same as the resolution of the map. Available end positions will be a multiple of this.</li>
<li><code>numAngles</code> - The number of discrete start orientations. A full set of primitives will be generated for each orientation.</li>
<li><code>numEndAngles</code> - The maximum number of end orientation. For each start orientation and each end orientation a full set of primitives will be generated. This is an upper boundry. It might not be reached.</li>
<li><code>destinationCircleRadius</code> - Radius around the robot (in cells) that primitives will be generated for.</li>
<li><code>cellSkipFactor</code> - Sparseness of the generated primitives.</li>
<li><code>splineOrder</code> Order of the generated splines.</li>
</ul>
<p>Based on the value of the parameter <code>destinationCircleRadius</code> a number of discrete destination points are generated on concentric circles. The parameter <code>CellSkipFactor</code> decides the interval between each two consecutive concentric circles. Before generating a motion primitive, each destination cell is scaled via multiplication with the <code>gridSize</code>. A unique motion primitives is generated for each start angle to each destination cell shown in picture below, from <code>(0,0)</code> to that cell for each end angle. The number of start angles and end angles is decided basd on the parameters <code>numAngles</code> and <code>numEndAngles</code> respectively.</p>
<p><img src="doc/figures/num_angles.png" alt="NumAngles" class="inline"/></p>
<p>To keep the number of primitives reasonable they are discretized. Their start and end positions are discretized using a 2d grid. The start and end orientations are discretized using angle segments.</p>
<p><img src="doc/figures/splines.gif" alt="NumAngles" class="inline"/></p>
<p>This animation shows all splines generated by the following configuration (each frame shows the primitives for one start orientation). </p><div class="fragment"><div class="line">config.gridSize = 0.1;</div>
<div class="line">config.numAngles = 24;</div>
<div class="line">config.numEndAngles = 12;</div>
<div class="line">config.destinationCircleRadius = 5;</div>
<div class="line">config.cellSkipFactor = 1.0;</div>
<div class="line">config.generatePointTurnMotions = false;</div>
<div class="line">config.generateLateralMotions = false;</div>
<div class="line">config.generateBackwardMotions = false;</div>
<div class="line">config.generateForwardMotions = true;</div>
<div class="line">config.splineOrder = 4;</div>
</div><!-- fragment --><p> <a class="anchor" id="autotoc_md21"></a> </p><h5>Default Parameters</h5>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter   </th><th class="markdownTableHeadLeft">Type   </th><th class="markdownTableHeadLeft">Description   </th><th class="markdownTableHeadLeft">Recommented Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dumpOnError   </td><td class="markdownTableBodyLeft">bool   </td><td class="markdownTableBodyLeft">Refer to the section <code>Dumping Planner State</code>   </td><td class="markdownTableBodyLeft">Release: 0, Debug: 1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dumpOnSuccess   </td><td class="markdownTableBodyLeft">bool   </td><td class="markdownTableBodyLeft">Refer to the section <code>Dumping Planner State</code>   </td><td class="markdownTableBodyLeft">Release: 0, Debug: 1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">initialPatchRadius   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft">Radius of initial patch of point cloud points to kick-start the planner   </td><td class="markdownTableBodyLeft">3.0   </td></tr>
</table>
<p><a class="anchor" id="autotoc_md22"></a> </p><h5>Mobility Configuration Parameters</h5>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter   </th><th class="markdownTableHeadLeft">Type   </th><th class="markdownTableHeadLeft">Description   </th><th class="markdownTableHeadLeft">Recommented Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">translationSpeed   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft">Linear velocity of the resulting path trajectory   </td><td class="markdownTableBodyLeft">1.0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">rotationSpeed   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft">Angular velocity of the resulting path trajectory   </td><td class="markdownTableBodyLeft">1.0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">minTurningRadius   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft">The minimum turning radius corresponds to the maximum curvature. This parameter therefore helps to select all motion primitives which have curvature less than the maximum curvature. A higher value means less cap for the maximum curvature resulting in linear primitives. A small value will result in more curvy primitives. Note that a smaller value results in more primitives selected which requires more computation power for the planning. For details see section <code>Minimum Turning Radius</code>   </td><td class="markdownTableBodyLeft">0.1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">multiplierForward   </td><td class="markdownTableBodyLeft">int   </td><td class="markdownTableBodyLeft">Cost multiplier for the forward motion primitives   </td><td class="markdownTableBodyLeft">1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">multiplierBackward   </td><td class="markdownTableBodyLeft">int   </td><td class="markdownTableBodyLeft">Cost multiplier for the backward motion primitives   </td><td class="markdownTableBodyLeft">2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">multiplierLateral   </td><td class="markdownTableBodyLeft">int   </td><td class="markdownTableBodyLeft">Cost multiplier for the lateral motion primitives   </td><td class="markdownTableBodyLeft">2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">multiplierForwardTurn   </td><td class="markdownTableBodyLeft">int   </td><td class="markdownTableBodyLeft">Cost multiplier for the forward turn motion primitives   </td><td class="markdownTableBodyLeft">1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">multiplierBackwardTurn   </td><td class="markdownTableBodyLeft">int   </td><td class="markdownTableBodyLeft">Cost multiplier for the backward turn motion primitives   </td><td class="markdownTableBodyLeft">2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">multiplierPointTurn   </td><td class="markdownTableBodyLeft">int   </td><td class="markdownTableBodyLeft">Cost multiplier for the point turn motion primitives   </td><td class="markdownTableBodyLeft">1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">multiplierLateralCurve   </td><td class="markdownTableBodyLeft">int   </td><td class="markdownTableBodyLeft">Cost multiplier for the lateral curve motion primitives   </td><td class="markdownTableBodyLeft">2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">searchRadius   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">1.0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">searchProgressSteps   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">0.1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">remove_goal_offset   </td><td class="markdownTableBodyLeft">bool   </td><td class="markdownTableBodyLeft">Remove the goal offset which is there because of the discretization   </td><td class="markdownTableBodyLeft">true    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">spline_sampling_resolution   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft">Resolution used to sample the motion primitive spline   </td><td class="markdownTableBodyLeft">0.01    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">maxMotionCurveLength   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft">The maximum curve length of the selected motion primitives. Small value results in small primitives and a large value results in longer primitives. During testing, it was observed that the planner has a hard time in finding a solution if the value of this parameter is set &lt; 0.6   </td><td class="markdownTableBodyLeft">1.3   </td></tr>
</table>
<p><a class="anchor" id="autotoc_md23"></a> </p><h5>Planner Configuration Parameters</h5>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter   </th><th class="markdownTableHeadLeft">Type   </th><th class="markdownTableHeadLeft">Description   </th><th class="markdownTableHeadLeft">Recommented Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">initialEpsilon   </td><td class="markdownTableBodyLeft">int   </td><td class="markdownTableBodyLeft">The planner uses ARA* planner. It finds a sub-optimal solution and then repairs the initial solution by using reducing the epsilon by the parameter <code>epsilonSteps</code>. An optimal solution means epsilon is equal to 1, where <code>solution = epsilon x optimal_solution</code>   </td><td class="markdownTableBodyLeft">36    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">epsilonSteps   </td><td class="markdownTableBodyLeft">int   </td><td class="markdownTableBodyLeft">The steps in the epsilon during planning and repairing of the initial sub-optimal solution   </td><td class="markdownTableBodyLeft">6    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">numThreads   </td><td class="markdownTableBodyLeft">int   </td><td class="markdownTableBodyLeft">A limit on the threads allocated for the planner during planning.   </td><td class="markdownTableBodyLeft">8    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">usePathStatistics   </td><td class="markdownTableBodyLeft">bool   </td><td class="markdownTableBodyLeft">Should a computationally expensive obstacle check be done to check whether the robot bounding box is in collision with obstacles. This mode is useful for highly cluttered and tight spaced environments.   </td><td class="markdownTableBodyLeft">false    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">searchUntilFirstSolution   </td><td class="markdownTableBodyLeft">bool   </td><td class="markdownTableBodyLeft">Search only until the first solution and then stop planning. See SBPL documentation for an explantion of this value.   </td><td class="markdownTableBodyLeft">false   </td></tr>
</table>
<p><a class="anchor" id="autotoc_md24"></a> </p><h5>Primitives Configuration Parameters</h5>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter   </th><th class="markdownTableHeadLeft">Type   </th><th class="markdownTableHeadLeft">Description   </th><th class="markdownTableHeadLeft">Recommented Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">gridSize   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft">The size of the traversability map grid   </td><td class="markdownTableBodyLeft">Use case specific    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">numAngles   </td><td class="markdownTableBodyLeft">int   </td><td class="markdownTableBodyLeft">number of discrete start angles angles. A full set of primitives will be generated for each start angle (has to be even number). For best performance, the value should be a multiple of 4. The multiple of 4 means that correct lateral motion primitives are generated. The reason for this is that the lateral motions are seen as 90 degree rotated motions from any given start angle. For this, the start angle is divided by 4 (because of 4 quadrants) and the result is subracted from the start angle   </td><td class="markdownTableBodyLeft">40    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">numEndAngles   </td><td class="markdownTableBodyLeft">int   </td><td class="markdownTableBodyLeft">The number of end angles for each destination cell. The value has to be &lt;= numAngles/2 and odd   </td><td class="markdownTableBodyLeft">9    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">destinationCircleRadius   </td><td class="markdownTableBodyLeft">int   </td><td class="markdownTableBodyLeft">See section <code>Motion Primitives</code>   </td><td class="markdownTableBodyLeft">6    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cellSkipFactor   </td><td class="markdownTableBodyLeft">int   </td><td class="markdownTableBodyLeft">See section <code>Motion Primitives</code>. It is best to leave this value at &gt;= 1 in integer steps. A value of less than 1 results in duplicate destination cells and do not add any value to the planning   </td><td class="markdownTableBodyLeft">1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">splineOrder   </td><td class="markdownTableBodyLeft">int   </td><td class="markdownTableBodyLeft">The value has to be &gt;= 3   </td><td class="markdownTableBodyLeft">3.0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">generateForwardMotions   </td><td class="markdownTableBodyLeft">bool   </td><td class="markdownTableBodyLeft">Generate forward motion primitives. Forward primitives are for the case where destination cell x-coordinate &gt; 0.1   </td><td class="markdownTableBodyLeft">Use case specific    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">generateBackwardMotions   </td><td class="markdownTableBodyLeft">bool   </td><td class="markdownTableBodyLeft">Generate backward motion primitives. Backward primitives are for the case where destination cell x-coordinate &lt; -0.1   </td><td class="markdownTableBodyLeft">Use case specific    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">generateLateralMotions   </td><td class="markdownTableBodyLeft">bool   </td><td class="markdownTableBodyLeft">Generate lateral motion primitives. Lateral primitives are for the case where the destination cell x-coordinate &gt; -0.1 and destination cell x-coordinate &lt; 0.1   </td><td class="markdownTableBodyLeft">Use case specific    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">generatePointTurnMotions   </td><td class="markdownTableBodyLeft">bool   </td><td class="markdownTableBodyLeft">Generate point-turn motion primitives. A point-turn is generated for each start angle to each end angle   </td><td class="markdownTableBodyLeft">Use case specific   </td></tr>
</table>
<p><a class="anchor" id="autotoc_md25"></a> </p><h5>Traversability Configuration Parameters</h5>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter   </th><th class="markdownTableHeadLeft">Type   </th><th class="markdownTableHeadLeft">Description   </th><th class="markdownTableHeadLeft">Recommented Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">maxStepHeight   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft">The maximum step height that the robot can traverse. This is used during map expansion. Steps heigher than this become map boundaries   </td><td class="markdownTableBodyLeft">Use case specific    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">maxSlope   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft">Maximum traversable slope above which no travmap entries will be generated   </td><td class="markdownTableBodyLeft">0.45    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">inclineLimittingMinSlope   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">0.2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">inclineLimittingLimit   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">0.1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">costFunctionDist   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft">Objects within a corridor of width costFunctionDist around a trajectory will influence the cost function. A higher value results in large computation cost requirements for the planning.   </td><td class="markdownTableBodyLeft">0.0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">minTraversablePercentage   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft">This value controls, how unknown patches are detected. If only a certain percentage of MSL patches are present on the surface of a traversability patch, it is rated as an unknown patch.   </td><td class="markdownTableBodyLeft">0.4    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">robotHeight   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">Use case specific    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">robotSizeX   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft">The length of the robot along x-axis   </td><td class="markdownTableBodyLeft">Use case specific    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">robotSizeY   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft">The length of the robot along y-axis   </td><td class="markdownTableBodyLeft">Use case specific    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">distToGround   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft">Distance from body frame to ground. Start and goal position are expected in body frame   </td><td class="markdownTableBodyLeft">Use case specific    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">slopeMetricScale   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">1.0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">slopeMetric   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft">The slope metric used to adjust the cost of a motion   </td><td class="markdownTableBodyLeft">Use case specific    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">gridResolution   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft">The resolution of the traversability grid map   </td><td class="markdownTableBodyLeft">Use case specific    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">initialPatchVariance   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">0.0001    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">allowForwardDownhill   </td><td class="markdownTableBodyLeft">bool   </td><td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">true    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">enableInclineLimitting   </td><td class="markdownTableBodyLeft">bool   </td><td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">false   </td></tr>
</table>
<p><a class="anchor" id="autotoc_md26"></a> </p><h5>Motion Primitive Filtering</h5>
<h6>Minimum Turning Radius</h6>
<p>The planner filters the primitives by <code>minTurningRadius</code> (i.e. all primitives that have a curvature that is larger than allowed by the minimum turning radius are ignored)</p>
<p>The following animation shows the same primitives as above but filtered with a <code>minTurningRadius</code> of <code>0.2</code>:</p>
<p><img src="doc/figures/splines_filtered.gif" alt="SplinesFiltered" class="inline"/></p>
<p>As you can see all sharp turns have been removed from the splines.</p>
<p>After filtering the splines are sampled using the planning grid resolution and the base cost for each motion is calculated. The sampled positions are later used during planning.</p>
<p>If your environment contains tight spots it is recommended to enable <code>generateBackwardMotions</code>. Otherwise the planner will have a hard time finding solutions to get to the correct end orientation in tight spots.</p>
<h6>Maximum Curve Length</h6>
<p>You can filter the primitives using the parameter <code>maxMotionCurveLength</code>. All primitives which have a curve length less than the <code>maxMotionCurveLength</code> will be selected.</p>
<p>The figure below shows the complete set of discritized splines, <b>without any curve length filter applied</b>, generated for the start angle of 0 radians. The green color signifies discritized primitives for forward motion, magenta for backward motion, and orange for lateral motion. Please note that the point-turns do not have a spline and therefore are not visible in the image below.</p>
<p><img src="doc/figures/max_curve_length.png" alt="MaxCurveLength" class="inline"/></p>
<p>The figure below shows the same set of discritized splines for start angle of 0 radians but with a <code>maxMotionCurveLength</code> of 1.2.</p>
<p><img src="doc/figures/max_curve_length_2.png" alt="MaxCurveLength2" class="inline"/></p>
<p>To get an idea about different geometric lengths of the primitives see the picture below. The picture shows only forward and backward motion primitives. Each arrow represents the end of a unqiue primitive. As mentioned earlier, the end points of the primitives are the destination cells scaled by the grid size of the traversability map.</p>
<p><img src="doc/figures/max_curve_length_3.png" alt="MaxCurveLength3" class="inline"/></p>
<p><a class="anchor" id="autotoc_md27"></a> </p><h5>Motions</h5>
<p>Each slected motion primitive is converted into a motion. A motion is a discritized motion primitive. In the planning phase, each discrete step of the motion is used to perform traversability and obstacle checks. You can find details on the motions in the class preComputedMotions.</p>
<p><a class="anchor" id="autotoc_md28"></a> </p><h5>Motion Base Cost Calculation</h5>
<p>Upon motion generation every motion is asigned a base cost. I.e. the cost that would arise when the robot would follow that motion on a horizontal flat surface. Factors for steepness and other penalties might be factored later during planning on a case to case basis.</p>
<p>The base cost for each motion is calculated as follows: </p><div class="fragment"><div class="line">translationDist = &lt; distance that the robot has to travel while following the spline &gt;</div>
<div class="line">rotationDist    = &lt; amount that the robot has to turn while following the spline &gt;</div>
<div class="line">translationTime = translationalDist / translationVelocity</div>
<div class="line">rotationTime    = rotationDist / angularVelocity</div>
<div class="line">travelTime      = max(rotationTime, translationTime)</div>
<div class="line">costMultiplier  = &lt; the configured multiplier for this particular motion type &gt;</div>
<div class="line">baseCost        = int(ceil(travelTime * 1000 * costMultiplier))</div>
</div><!-- fragment --><p> The travelTime is scaled by 1000 to retain three digits of precision when converting to integer.</p>
<p><a class="anchor" id="autotoc_md29"></a> </p><h5>Motion Cost Scaling</h5>
<p>Since all primitives are 2-dimensional the <code>baseCost</code> is only accurat on perfectly flat terrain. To factor in the slope of the terrain the cost is scaled based on one of the following metrics during planning.</p>
<h6>SlopeMetric::NONE</h6>
<div class="fragment"><div class="line">cost = motion.baseCost;</div>
</div><!-- fragment --> <h6>SlopeMetric::AVG_SLOPE</h6>
<div class="fragment"><div class="line">slopeFactor = &lt; avg slope under spline&gt; * config.slopeMetricScale;</div>
<div class="line">cost = motion.baseCost + motion.baseCost * slopeFactor;</div>
</div><!-- fragment --> <h6>SlopeMetric::MAX_SLOPE</h6>
<div class="fragment"><div class="line">slopeFactor = &lt; max slope under spline&gt; * config.slopeMetricScale;</div>
<div class="line">cost = motion.baseCost + motion.baseCost * slopeFactor;</div>
</div><!-- fragment --> <h6>SlopeMetric::TRIANGLE_SLOPE</h6>
<p>This one is a little tricky. We take the length of the spline and project it onto the slope between the start and end position. Then we measure the length of the projected line and use that to re-calculate the cost using the base cost formula (see above). This should give a good approximation of the real travel time needed to move up (or down) a slope. </p><div class="fragment"><div class="line">heightDiff = &lt; height difference between start and end of motion &gt;</div>
<div class="line">approxMotionLen = sqrt(motion.translationlDist^2 + heightDiff^2)</div>
<div class="line">cost = calculateCost(approxMotionLen)</div>
</div><!-- fragment --><p>None of those metrices captures the real cost of moving up or down a slope. They have been implemented for experimentation. However those experiments have never been done (we ran out of time and there where no slopes in the final demo). Thus the performance of the metrices is unclear.</p>
<h4><a class="anchor" id="autotoc_md30"></a>
Dumping Planner State</h4>
<p>In case of error the <code>Planner</code> dumps its state to a file (this can be enabled using the <code>dumpOnError</code> parameter). The state can be loaded and analyzed using the <code>ugv_nav4d_replay</code> binary. This binary loads the state and executes the planning in a controlled environment. This can be used to debug the planner.</p>
<h4><a class="anchor" id="autotoc_md31"></a>
User Interfaces</h4>
<p>Two user interfaces can be found in <code>src/gui</code>. They are intended for testing and debugging.</p>
<p><a class="anchor" id="autotoc_md32"></a> </p><h5><a class="el" href="classPlannerGui.html">PlannerGui</a></h5>
<p>The <code><a class="el" href="classPlannerGui.html">PlannerGui</a></code> is the main testing gui. It is designed to experiment with differen planner parameters on a static map. It can load point clouds from ply or serialized mls maps. A left click sets the start location, a right click sets the end location.</p>
<p>In addition the <code><a class="el" href="classPlannerGui.html">PlannerGui</a></code> can also be used to load and analyze planner dumps.</p>
<h2><a class="anchor" id="autotoc_md33"></a>
Bug Reports</h2>
<p>To search for bugs or report them, please use GitHubs <a href="https://github.com/dfki-ric/ugv_nav4d/issues">Issue-Tracker</a> </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
